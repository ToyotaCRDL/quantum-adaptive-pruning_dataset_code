import qutip as qt
import numpy as np
import scipy
from functools import reduce
import operator
import sys

# Constants
N_QUBITS = 6  # Number of qubits
DEPTH = 10    # Number of layers
ENTANGLER_TYPE = 1  # 0:CZ, 1:CX
ENTANGLER_ARRANGEMENT = 1  # 0: All-to-All, 1: Chain-Block, 2: Nearest-Neighbor
SEED = 12345
LEVELS = 2
CUTOFF_EIGVALS = 1e-12
EPOCHS = 100
LEARNING_RATE = 0.004
MOMENT = 0.5
VFV = 0.004  # Pruning-threshold value
BATCH_SIZE = 20
EPSILON = 0.01
N_PARAMETERS = DEPTH * N_QUBITS  # Number of parameters of circuit

# Seed initialization
rng = np.random.default_rng(seed=SEED)

def initialize_angles(depth, n_qubits):
    """Generate initial angles for the quantum circuit"""
    return np.sqrt(6) / np.sqrt(2 * depth) * (2 * rng.random([depth, n_qubits]) - 1)

def gen_fock_operator(op, position, size, levels=LEVELS):
    """Generate tensor product of single-qubit operators"""
    op_list = [qt.qeye(levels) for _ in range(size)]
    op_list[position] = op
    return qt.tensor(op_list)

def create_entangling_layer(n_qubits, arrangement, entangler_type):
    """Create entangling layers based on arrangement and type"""
    if arrangement == 0:  # All-to-All
        entangling_gate_index = [[i, j] for i in range(n_qubits) for j in range(i + 1, n_qubits)]
    elif arrangement == 1:  # Chain-Block
        entangling_gate_index = [[i, i + 1] for i in range(n_qubits - 1)] + [[n_qubits - 1, 0]]
    elif arrangement == 2:  # Nearest-Neighbor
        entangling_gate_index = [[2 * i, 2 * i + 1] for i in range(n_qubits // 2)] + \
                                [[2 * i + 1, 2 * i + 2] for i in range((n_qubits - 1) // 2)]
    else:
        raise ValueError("Invalid entangling arrangement specified.")

    # Create entangling operations
    gates = []
    for j, k in entangling_gate_index:
        if entangler_type == 0:  # CZ
            gates.append(qt.qip.operations.csign(n_qubits, j, k))
        elif entangler_type == 1:  # CX
            gates.append(qt.qip.operations.cnot(n_qubits, j, k))
        else:
            raise ValueError("Invalid entangling gate type specified.")
    return reduce(operator.mul, gates[::-1], 1)

def calculate_qfi(circuit_state, grad_state_list, n_parameters):
    """Compute the Quantum Fisher Information (QFI) matrix"""
    single_qfi_elements = np.array([circuit_state.overlap(gs) for gs in grad_state_list])
    qfi_matrix = np.zeros((n_parameters, n_parameters))

    for p in range(n_parameters):
        for q in range(p, n_parameters):
            qfi_matrix[p, q] = np.real(grad_state_list[p].overlap(grad_state_list[q]) - 
                                       np.conjugate(single_qfi_elements[p]) * single_qfi_elements[q])
    qfi_matrix = qfi_matrix + qfi_matrix.T - np.diag(np.diag(qfi_matrix))
    return qfi_matrix

def get_states_gradients(ini_pauli, ini_angles, n_parameters, n_qubits, depth, levels=LEVELS):
    gradient_list = np.zeros(n_parameters)
    grad_state_list = []
    for p in range(-1, n_parameters):
        counter = 0
        initial_state = qt.tensor([qt.basis(levels, 0) for i in range(n_qubits)])
        initial_state = qt.tensor([qt.qip.operations.ry(np.pi/2) for i in range(n_qubits)])*initial_state

        # go through depth layers
        for j in range(depth):
            rot_op = []
            # define parametrized single-qubit rotations at layer j
            for k in range(n_qubits):
                if(ini_pauli[j][k] != 0):
                    angle = ini_angles[j][k]
                    if(ini_pauli[j][k] == 1):
                        rot_op.append(qt.qip.operations.rx(angle))
                    elif(ini_pauli[j][k] == 2):
                        rot_op.append(qt.qip.operations.ry(angle))
                    elif(ini_pauli[j][k] == 3):
                        rot_op.append(qt.qip.operations.rz(angle))

                    # multiply in derivative of parametrized single-qubit rotation gate at layer j for parameter of circuit p
                    if(counter == p):
                        if(ini_pauli[j][k] == 1):
                            initial_state = (-1j*op_x[k]/2)*initial_state
                        elif(ini_pauli[j][k] == 2):
                            initial_state = (-1j*op_y[k]/2)*initial_state
                        elif(ini_pauli[j][k] == 3):
                            initial_state = (-1j*op_z[k]/2)*initial_state
                    counter = counter + 1
                else:
                    rot_op.append(qt.qeye(2))
            # multiply in single-qbuit rotations 
            initial_state = qt.tensor(rot_op)*initial_state
            # add entangling layer
            initial_state = entangling_layer*initial_state

        if(p == -1): # get quantum state for cost function
            # cost function given by <\psi|H|\psi>
            circuit_state = qt.Qobj(initial_state)  # state generated by circuit
            energy = 0.0
        else: # get quantum state needed for gradient
            grad_state_list.append(qt.Qobj(initial_state))  # state with gradient applied for p-th parameter
            circuit_state = qt.Qobj(initial_state)  # state generated by circuit
            energy = 0.0
            gradient_list[p] = 2*np.real(circuit_state.overlap(initial_state))
    return circuit_state, energy, grad_state_list,gradient_list

def pruning(ini_angles, ini_pauli, depth, n_parameters, qfi_matrix, eigvals, cutoff_eigvals, vfv):
    nonzero_eigvals = eigvals[eigvals > cutoff_eigvals]        
    eff_quant_dim = len(nonzero_eigvals)
    n_zero_eigval = n_parameters - eff_quant_dim

    # fraction of zero eigenvalues
    redundancy = n_zero_eigval / n_parameters
    weights_zeros = np.zeros(n_parameters)
    for i in range(n_parameters):
        if(eigvals[i] < cutoff_eigvals):
            weights_zeros[:] += np.abs(eigvecs[:, i])**2
            
        # find which parameters can be pruned
        reduced_parameters = n_parameters
        reduced_eigvecs = np.array(eigvecs)
        reduced_eigvals = np.array(eigvals)
        reduced_weights_zeros = np.array(weights_zeros)
        reduced_qfi_matrix = np.array(qfi_matrix)
        removed_index = []
        reduced_n_zero_eigval = n_parameters - eff_quant_dim
        theta_list = []
        for i in range(depth):
            for j in range(n_qubits):
                if ini_pauli[i,j] != 0:
                    theta_list.append(ini_angles[i][j])
        theta_list = theta_list/np.linalg.norm(theta_list)
        vqv_init = np.dot(np.transpose(theta_list), np.dot(reduced_qfi_matrix, theta_list))
        vqv_list_indx = []
        vqv_list_val = []
        while(reduced_n_zero_eigval > 0):
            reduced_zero_eigvals_index = np.arange(reduced_parameters)[reduced_weights_zeros > 10**-14]
            delete_index = reduced_zero_eigvals_index[-1]
            removed_index.append(delete_index)
            reduced_qfi_matrix = np.delete(reduced_qfi_matrix, delete_index, axis=0)
            reduced_qfi_matrix = np.delete(reduced_qfi_matrix, delete_index, axis=1)
            reduced_parameters = reduced_paramters - 1
            reduced_eigvals, reduced_eigvecs = scipy.linalg.eigh(reduced_qfi_matrix)
            reduced_weights_zeros = np.zeros(reduced_parameters)
            theta_list = np.delete(theta_list, delete_index, axis=0)
            vqv = np.dot(np.transpose(theta_list), np.dot(reduced_qfi_matrix, theta_list))
            if vqv < vfv:
                counter = 0
                for i in range(depth):
                    for j in range(n_qubits):
                        if counter == delete_index and ini_pauli[i,j]!=0:
                            vqv_list_indx.append(delete_index)
                            vqv_list_val.append(vqv)
                        counter = counter + 1
            for i in range(reduced_parameters):
                if(reduced_eigvals[i] < cutoff_eigvals):  # only get weights for zero eigvals
                    reduced_weights_zeros[:] += np.abs(reduced_eigvecs[:, i])**2
            reduced_n_zero_eigval = 0
            for i in range(reduced_parameters):
                if(reduced_eigvals[i] < cutoff_eigvals):
                    reduced_n_zero_eigval = reduced_n_zero_eigval + 1

        if len(vqv_list_indx) > 0 and vqv_init > np.percentile(vqv_list_val, 50):
            for j, i in enumerate(vqv_list_indx):
                if vqv_list_val[j] < vqv_init:
                    removed_index.remove(i)
        else:
            removed_index = []

        # check removed index
        counter = 0
        for i in range(depth):
            for j in range(n_qubits):
                if counter in removed_index and ini_pauli[i, j] == 0:
                    removed_index.remove(counter)
                counter = counter + 1

        # post-processing after removed
        if len(removed_index) > 0:
            counter = 0
            for i in range(depth):
                for j in range(n_qubits):
                    if(counter in removed_index):  # if has been removed by pruning, set pauli rotation to zero
                        ini_pauli[i, j] = 0
                    counter = counter + 1

            # re-arrangement: update depth and number of parameters
            for i in range(n_qubits):
                for _ in range(depth):
                    for j in range(depth-1):
                        if ini_pauli[j][i] == 0 and ini_pauli[j+1][i] != 0:
                            ini_angles[j][i] = ini_angles[j+1][i]
                            ini_pauli[j][i] = ini_pauli[j+1][i]
                            ini_pauli[j+1][i] = 0
            k = 0
            for i in range(depth):
                if np.sum(ini_pauli[i]) > 0:
                    k = k + 1
            if k < depth:
                depth = k
            n_p_t = np.count_nonzero(ini_pauli[:depth])
            if n_p_t < n_parameters:
                n_parameters = n_p_t
            removed_index = []
    return ini_angles, ini_pauli, depth, n_parameters


# main loop/optimize_prune_angles
def optimize_prune_angles(epochs, data, batch_size, ini_angles, n_parameters, n_qubits, depth, rate, moment, entangling_layer, hamiltonian, vfv, levels=LEVELS):
    n_y = len(data[0]) - 1
    data[:, :n_qubits] = np.pi / 2 * (data[:, :n_qubits] + 1.0) / 2  # features (x) in [0, pi/2]
    mini_batches = create_mini_batches(data, batch_size)
    ini_angles_temp = np.zeros([depth, n_qubits])
    ini_pauli = np.full([depth, n_qubits], 2)  # define rotations for circuit in each layer, 1: X, 2:Y 3:Z
    removed_index = []
    qfi_inv_matrix = np.zeros([n_parameters, n_parameters])
    mmm = np.zeros(n_parameters)

    for m in range(epochs):
        d_c = 0
        err = 0
        for mini_batch in mini_batches:
            counter = 0
            for i in range(depth):
                for j in range(n_qubits):
                    if m > 0 and ini_pauli[i, j] != 0:
                        ini_angles_temp[i, j] = ini_angles[i, j] - rate*dp[counter][0] + moment*mmm[counter]
                        mmm[counter] = -rate*dp[counter][0]
                        counter = counter + 1
                    else:
                        ini_angles_temp[i, j] = ini_angles[i, j]
            err1 = 0
            for mini_batch_one in mini_batch:
                d_c = d_c + 1
                initial_state = qt.tensor([qt.basis(levels, 0) for i in range(n_qubits)])

                # initial layer of fixed \sqrt{H} rotations Hadmard
                initial_state = qt.tensor([qt.qip.operations.ry(np.pi/2) for i in range(n_qubits)])*initial_state
                # data encoding
                initial_state = qt.tensor([qt.qip.operations.ry(mini_batch_one[i]) for i in range(n_qubits)])*initial_state

                # go through depth layers
                for j in range(depth):
                    rot_op = []
                    # make parametrized single-qubit rotations at layer j
                    for k in range(n_qubits):
                        angle = ini_angles_temp[j][k]
                        if(ini_pauli[j][k] == 1):
                            rot_op.append(qt.qip.operations.rx(angle))
                        elif(ini_pauli[j][k] == 2):
                            rot_op.append(qt.qip.operations.ry(angle))
                        elif(ini_pauli[j][k] == 3):
                            rot_op.append(qt.qip.operations.rz(angle))
                        elif(ini_pauli[j][k] == 0):
                            rot_op.append(qt.qeye(2))
                    # multiply in single-qbuit rotations 
                    initial_state = qt.tensor(rot_op)*initial_state
                    # add entangling layer
                    initial_state = entangling_layer*initial_state

                # cost function given by <\psi|H|\psi>
                circuit_state = qt.Qobj(initial_state)  # state generated by circuit
                energy = qt.expect(hamiltonian, circuit_state)
                y_t = mini_batch_one[n_y]
                err1 = err1 + (energy - y_t)**2
            ini_angles = ini_angles_temp
            err = err + err1

            circuit_state, energy, grad_state_list, gradient_list = get_states_gradients(ini_pauli, ini_angles, n_parameters, n_qubits, depth)
            qfi_matrix = calculate_qfi(circuit_state, grad_state_list, n_parameters)
            eigvals, eigvecs = scipy.linalg.eigh(qfi_matrix)
            eigvals_inv = np.zeros(n_parameters)
            for i in range(n_parameters):
                if(eigvals[i] < 10**-2):  # cutoff eigvals
                    eigvals_inv[i] = 0  # inverted eigenvalues with cutoff of smallest eigenvalues set to zero
                else:
                    eigvals_inv[i] = 1/eigvals[i]
            qfi_inv_matrix = np.dot(eigvecs, np.dot(np.diag(eigvals_inv), np.transpose(np.conjugate(eigvecs))))
            temp = np.zeros([depth,n_qubits])
            delta_p = rng.random(n_parameters)
            delta_p[delta_p > 0.5] = 1
            delta_p[delta_p <= 0.5] = -1

            # SPSA
            d_f = 0.0
            num_mb_size = len(mini_batch)
            for sign in [1.0, -1.0]:
                err2  =  0
                for mini_batch_one in mini_batch:
                    counter = 0
                    for j in range(depth):
                        for k in range(n_qubits):
                            if ini_pauli[j][k] != 0:
                                temp[j][k] = ini_angles[j][k] + EPSILON * sign * delta_p[counter]
                                counter = counter + 1
                    initial_state = qt.tensor([qt.basis(levels,0) for i in range(n_qubits)])
                    initial_state = qt.tensor([qt.qip.operations.ry(np.pi/2) for i in range(n_qubits)])*initial_state
                    # data encoding
                    initial_state = qt.tensor([qt.qip.operations.ry(mini_batch_one[i]) for i in range(n_qubits)])*initial_state
                    for j in range(depth):
                        rot_op = []
                        for k in range(n_qubits):
                            angle = temp[j][k]
                            if(ini_pauli[j][k] == 1):
                                rot_op.append(qt.qip.operations.rx(angle))
                            elif(ini_pauli[j][k] == 2):
                                rot_op.append(qt.qip.operations.ry(angle))
                            elif(ini_pauli[j][k] == 3):
                                rot_op.append(qt.qip.operations.rz(angle))
                            elif(ini_pauli[j][k] == 0):
                                rot_op.append(qt.qeye(2))
                        initial_state = qt.tensor(rot_op)*initial_state
                        initial_state = entangling_layer*initial_state
                    circuit_state = qt.Qobj(initial_state)  # state generated by circuit
                    energy = qt.expect(hamiltonian, circuit_state)
                    y_t = mini_batch_one[n_y]
                    err2 = err2 + (energy - y_t)**2
                d_f += sign*err2/num_mb_size
            delta_f_mean = d_f/2/EPSILON/delta_p
            dp = np.dot(qfi_inv_matrix, delta_f_mean.reshape(n_parameters, 1))

        # pruning
        if m > 4:
            ini_angles, ini_pauli, depth, n_parameters = pruning(ini_angles, ini_pauli, depth, n_parameters, qfi_matrix, eigvals, cutoff_eigvals, vfv)

        print(m+1, np.sqrt(err/d_c), file=sys.stderr)
    return ini_angles, n_parameters

def create_mini_batches(data, batch_size):
    mini_batches = []
    rng.shuffle(data, axis=0)
    n_minibatches = data.shape[0] // batch_size
    for i in range(n_minibatches + 1):
        mini_batch = data[i * batch_size: (i + 1) * batch_size, :]
        if len(mini_batch) > 0:
            mini_batches.append(mini_batch)
    if data.shape[0] % batch_size != 0:
        mini_batch = data[i * batch_size: data.shape[0]]
        if len(mini_batch) > 0:
            mini_batches.append(mini_batch)
    return mini_batches

# Initialization
initial_angles = initialize_angles(DEPTH, N_QUBITS)
entangling_layer = create_entangling_layer(N_QUBITS, ENTANGLER_ARRANGEMENT, ENTANGLER_TYPE)
op_x = [gen_fock_operator(qt.sigmax(), i, N_QUBITS) for i in range(N_QUBITS)]
op_y = [gen_fock_operator(qt.sigmay(), i, N_QUBITS) for i in range(N_QUBITS)]
op_z = [gen_fock_operator(qt.sigmaz(), i, N_QUBITS) for i in range(N_QUBITS)]
hamiltonian = op_z[0]

# Example usage
data = np.loadtxt("./data-machine.dat")
optimized_angles, n_parameters = optimize_prune_angles(EPOCHS, data, BATCH_SIZE, initial_angles, N_PARAMETERS, N_QUBITS, DEPTH, LEARNING_RATE, MOMENT, entangling_layer, hamiltonian, VFV)
